## 함수의 오버로딩 이란?

이름이 동일한 함수에 인자를 다르게 해서 과부하를 줍니다. 



## static 이란?

static 변수 또는 함수를 클래스 내부에 설정하면, 특정 객체에 종속되지 않고 클래스에 종속하게 된다. 한마디로 같은 클래스 내에서 static은 공유가 가능합니다.



## const 이란?

const은 읽기전용입니다. const 변수는 수정이 불가능합니다.

const 함수는 멤버변수의 수정이 불가능하고 상수함수만 호출할 수 있습니다. 하지만 mutable를 활용해서 멤버변수를 접근 가능하게 할 수도 있습니다.



## 생성자 리스트의 장점 

생성자리스트는 생성과 초기화를 동시에 합니다. 이에 따른 장점은 

1. 만약 type이 클래스이면 생성자리스트는 복사생성자만 호출하고 생성자리스트를 쓰지 않았으면 생성자를 호출하고 대입연산자를 호출한다. 따라서 전자가 더 효율적인 작업입니다.
2. 상수와 레퍼런스들은 모두 생성과 동시게 초기화가 되어야해서 무조건 초기화 리스트를 사용해야한다.



## 레퍼런스 인자를 사용하는 이유?

값을 받지 않고 주소값을 받습니다. 

여기서 불필요한 복사가 일어나지 않습니다. 만약  인자가 레퍼런스가 아닌데 큰 데이터가 들어있는 컨테이너, 구조체, 클래스 이면 안에 있는 element를 다 복사하니깐 속도도 느리고 비효율적 입니다.



## 깊은 복사 or 얕은 복사

디볼트 복사 생성자 or 대입 연산자는 대입만 해주는 __얕은 복사(shallow copy)__ 일어납니다. 여기서 동적으로 할당된 메모리를 동시 참조하다가 a에서 delete를 해주고 b에서 delete된 메모리를 호출하면 런타임 에러가 발생합니다. 이러한 문제점을 해결하기 위해서는 따로 메모리에 동적 할당해서 복사하는 방법 즉 깊은 복사를 해야 합니다.



## malloc() 과 new의 차이

malloc()은 함수이고 , new는 연산자입니다. 큰 차이점은 생성자 유무 입니다. malloc()은 시스템 함수로서 함수 안에서 메모리를 할당하지만 new는 연산자로 바로 메모리를 할당하는게 아니라 생성자를 호출하여 메모리를 할당합니다. 그러므로 생성 시 초기화가 가능한 장점이 있습니다.



## 객체지향언어 vs 절차지향언어

절차지향언어는 순차적 실행, 컴퓨터의 처리구조와 유사해 객체지향보다 빠른 처리가능, 계산중심언어, 함수가 중심이 되고 데이터는 보조기능입니다.

객체지향언어는 실제 세계를 모델링 또한 추상화, 캡슐화, 상속, 다형성의 특징이 있습니다

- 추상화 : 수행과정이 비슷한 개념으로 묶어 정의(선언)하는 것을 추상화라고 합니다.
- 캡슐화 : 프로퍼티(변수)와 메소드(함수)가 하나의 캡슐 안에 묶인 특성을 말합니다.
- 상속성 : 하나의 클래스가 가지고 있는 특징을 그대로 다른 클래스에게 물려줍니다.
- 다형성 : 하나의 객체가 여러 형태를 가질 수 있음을 의미합니다. 대표적으로 오버라이딩과 오버로딩이 있습니다.



## 프로세스 & 스레드

프로세스 : 프로그램을 메모리 상에서 실행중인 작업 

스레드 : 프로세스 안에서 실행되는 여러 흐름 단위



프로세스는 각각 별도의 주소공간 할당(독립적)

- code : 코드 자체를 구성하는 메모리 영역(프로그램 명령)
- Data : 전역변수, static, 배열등
  - 초기화 된 데이터는 data영역에 저장
  - 초기화 되지 않은 데이터는 bss 영역에 저장
- Heep : 동적 할당시 사용(new(), malloc()) 등
- Stack : 지역변수, 매개변수, 리턴값 (임시 메모리 영역)



스레드는 Stack만 따로 할당 받고 나머지 영역은 서로 공유 

하나의 프로세스가 생성될 때, 기본적으로 하나의 스레드 같이 생성

**프로세스는 자신만의 고유 공간과 자원을 할당받아 사용**하는데 반해, **스레드는 다른 스레드와 공간, 자원을 공유하면서 사용**하는 차이가 존재함



## c++ 4가지 캐스팅

- `static_cast` : 우리가 흔히 생각하는, 언어적 차원에서 지원하는 일반적인 타입 변환
- `const_cast` : 객체의 상수성(const) 를 없애는 타입 변환. 쉽게 말해 `const int` 가 `int` 로 바뀐다.
- `dynamic_cast` : 파생 클래스 사이에서의 다운 캐스팅 (→ 정확한 의미는 나중에 다시 배울 것입니다)
- `reinterpret_cast` : 위험을 감수하고 하는 캐스팅으로 서로 관련이 없는 포인터들 사이의 캐스팅 등



## 소멸자의 virtual 키워드

기반 클래스의 가리키는 파생 클래스 `a` 가 동적으로 메모리가 할당 되어 있는 상태에서  `a` 가 `delete` 될 때 소멸자에 `virtual` 키워드를 명시하지 않으므로 소멸자는 정적바인딩 되어 있는 상태이여서 컴파일 단계에서 형이 기반클래스를 이므로 기반클래스에 소멸자만 호출 한다 따라서 메모리 누수가 발생한다. 소멸자의 `virtual` 키워드를 명시하면 동적바인딩 되여서 소멸자를 호출시 런타임 단계에서 가상함수테이블를 거치면서 기반클래스의 소멸자를 찾아서 호출시켜준다.



## 스마트포인터의 존재

똑똑한 포인터의 역할을 하는 객체 입니다. 적은버그, 자동청소, 자동초기화, 댕글링포인터 등에 대한 이점이 있습니다. std::unique_ptr은 있으면 소유권을 독접하기 때문에 복사생성이 안됩니다. 그러나 이동(소유권이전)은 가능합니다.



## 동기화(mutex, atomic) 을 사용하는 이유?

CPU에서 연산을 할 떄 레지스터에 연산을 합니다. 예를들어 a 랑 b 쓰레드가 있습니다.

a가 역참조된 변수에 레지스터에 `add`연산자로 1을 더하기전에 b가 먼저 `add`연산자로 1을 더했습니다. 하지만 a는 `add`를 하기 전 상황이므로 `add`를 하면 변수의 결과값을 뒤덮어서  +1이라는 계산을 한번 누락시키게 됩니다. 



![iostream1](../img/tread1.PNG)
