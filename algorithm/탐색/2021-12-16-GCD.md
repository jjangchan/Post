# 유클리드 호제법

두 수의 최대공약수를 구하는 알고리즘



## 계산법

`mod` 연산으로 구한다.

`MOD연산이란? 두 값을 나눈 나머지를 구하는 연산`

`a` = 1112, `b` =  695 이면,

큰 수를 작은 수로 나눈 나머지를 구한다.

```
1112 mode 695 = 417
```

나눴던 수랑 나머지를 `mod` 연산을 반복한다.

```
695 mod 417 = 278
417 mod 278 = 139
```

계속 반복하면,

```
278 mod 139 = 0
```

나머지가 0이 되면 마지막 나눴던 `139` 가 `1112`와`695` 의 `최대공약수` 가 된다.



# 유클리드 호제법 증명

2개의 자연수 A,B가 있고 A%B = r 이라고 하면 다음을 만족한다.
$$
GCD(A, B)=GCD(B,r)
$$
A, B에게 G라는 최대공약수가 있다면 다음과 같이 나타난다.
$$
A = aG, \ B = bG
$$
G가 최대공약수이기 때문에 a,b는 반드시 서로소여야 한다.

`A mod B = r` 이기 때문에, 몫을 `q` 라고 하면 아래식이 유도된다.
$$
A=Bq+r \ \rightarrow \ aG=bGq+r \ \rightarrow \ r = (a-bq)G, \ B=bG
$$
`r` 과 `B` 는 최대공약수 `G` 을 가지고 있으므로, `a-bq` 와 `b` 는 서로소임을 증명하면된다.

여기서 서로소가 아니라고 과정하면 두 수는 공약수를 갖기 때문에 다음과 같다.
$$
a-bq = np, \ b = mp \ \rightarrow \ a = (n+mq)p, \ b=mp
$$
여기서 `a,b`는 서로소인데 `p`라는 공약수를 갖으므로 조건에 위배된다. 따라서, `a-bq`와 `b`는 서로소이다.

결국, `B`와 `r`의 최대공약수는 `G`이다. 이렇게 유클리드 호제법이 증명된다.



## code

```c++
// "a" must be greater than "b"
int GCD(int a, int b){
    return a%b ? GCD(b, a%b) : b;
}
```







> 출처
>
> https://sexycoder.tistory.com/65
>
> https://velog.io/@yerin4847/W1-%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C-%ED%98%B8%EC%A0%9C%EB%B2%95

